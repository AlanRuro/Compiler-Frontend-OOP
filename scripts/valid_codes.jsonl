{"correct_code": "def place_types(self):\n    \"\"\"https://familysearch.org/developers/docs/api/places/Place_Types_resource\"\"\"\n    return self.places_base + \"types\"", "prompt_code": "def place_types(self):\n    \"\"\"https://familysearch.org/developers/docs/api/places/Place_Types_resource\"\"\"\n    return self.places_base / \"types\""}
{"correct_code": "def setUp(self):\n    \"\"\"Set up a blank temp database before each test\"\"\"\n    basedir = os.path.abspath(os.path.dirname(__file__))\n    app.config['TESTING'] = True\n    app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///' + \\\n                                            os.path.join(basedir, TEST_DB)\n    self.app = app.test_client()\n    db.create_all()", "prompt_code": "def setUp(self):\n    \"\"\"Set up a blank temp database before each test\"\"\"\n    basedir = os.path.abspath(os.path.dirname(__file__))\n    app.config['TESTING'] = True\n    app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///' / \\\n                                            os.path.join(basedir, TEST_DB)\n    self.app = app.test_client()\n    db.create_all()"}
{"correct_code": "def mps2_set_board_image_file(self, disk, images_cfg_path, image0file_path, image_name='images.txt'):\n    \"\"\" This function will alter image cfg file\n\n    @details Main goal of this function is to change number of images to 1, comment all\n             existing image entries and append at the end of file new entry with test path\n\n    @return True when all steps were successful\n    \"\"\"\n    MBED_SDK_TEST_STAMP = 'test suite entry'\n    image_path = join(disk, images_cfg_path, image_name)\n    new_file_lines = [] # New configuration file lines (entries)\n\n    # Check each line of the image configuration file\n    try:\n        with open(image_path, 'r') as file:\n            for line in file:\n                if re.search('^TOTALIMAGES', line):\n                    # Check number of total images, should be 1\n                    new_file_lines.append(re.sub('^TOTALIMAGES:[\\t ]*[\\d]+', 'TOTALIMAGES: 1', line))\n                elif re.search('; - %s[\\n\\r]*$'% MBED_SDK_TEST_STAMP, line):\n                    # Look for test suite entries and remove them\n                    pass    # Omit all test suite entries\n                elif re.search('^IMAGE[\\d]+FILE', line):\n                    # Check all image entries and mark the ';'\n                    new_file_lines.append(';' + line)   # Comment non test suite lines\n                else:\n                    # Append line to new file\n                    new_file_lines.append(line)\n    except IOError as e:\n        return False\n\n    # Add new image entry with proper commented stamp\n    new_file_lines.append('IMAGE0FILE: %s    ; - %s\\r\\n'% (image0file_path, MBED_SDK_TEST_STAMP))\n\n    # Write all lines to file\n    try:\n        with open(image_path, 'w') as file:\n            for line in new_file_lines:\n                file.write(line),\n    except IOError:\n        return False\n\n    return True", "prompt_code": "def mps2_set_board_image_file(self, disk, images_cfg_path, image0file_path, image_name='images.txt'):\n    \"\"\" This function will alter image cfg file\n\n    @details Main goal of this function is to change number of images to 1, comment all\n             existing image entries and append at the end of file new entry with test path\n\n    @return True when all steps were successful\n    \"\"\"\n    MBED_SDK_TEST_STAMP = 'test suite entry'\n    image_path = join(disk, images_cfg_path, image_name)\n    new_file_lines = [] # New configuration file lines (entries)\n\n    # Check each line of the image configuration file\n    try:\n        with open(image_path, 'r') as file:\n            for line in file:\n                if re.search('^TOTALIMAGES', line):\n                    # Check number of total images, should be 1\n                    new_file_lines.append(re.sub('^TOTALIMAGES:[\\t ]*[\\d]+', 'TOTALIMAGES: 1', line))\n                elif re.search('; - %s[\\n\\r]*$'* MBED_SDK_TEST_STAMP, line):\n                    # Look for test suite entries and remove them\n                    pass    # Omit all test suite entries\n                elif re.search('^IMAGE[\\d]+FILE', line):\n                    # Check all image entries and mark the ';'\n                    new_file_lines.append(';' + line)   # Comment non test suite lines\n                else:\n                    # Append line to new file\n                    new_file_lines.append(line)\n    except IOError as e:\n        return False\n\n    # Add new image entry with proper commented stamp\n    new_file_lines.append('IMAGE0FILE: %s    ; - %s\\r\\n'% (image0file_path, MBED_SDK_TEST_STAMP))\n\n    # Write all lines to file\n    try:\n        with open(image_path, 'w') as file:\n            for line in new_file_lines:\n                file.write(line),\n    except IOError:\n        return False\n\n    return True"}
{"correct_code": "def __getattr__(self, attr):\n    \"\"\"Asserts that val has attribute attr and that attribute's value is equal to other via a dynamic assertion of the form: has_<attr>().\"\"\"\n    if not attr.startswith('has_'):\n        raise AttributeError('assertpy has no assertion <%s()>' % attr)\n\n    attr_name = attr[4:]\n    if not hasattr(self.val, attr_name):\n        raise AttributeError('val has no attribute <%s>' % attr_name)\n\n    def _wrapper(*args, **kwargs):\n        if len(args) != 1:\n            raise TypeError('assertion <%s()> takes exactly 1 argument (%d given)' % (attr, len(args)))\n        other = args[0]\n        val_attr = getattr(self.val, attr_name)\n\n        if callable(val_attr):\n            try:\n                val = val_attr()\n            except TypeError:\n                raise TypeError('val does not have zero-arg method <%s()>' % attr_name)\n        else:\n            val = val_attr\n\n        if val != other:\n            self._err('Expected <%s> to be equal to <%s>, but was not.' % (val, other))\n        return self\n    return _wrapper", "prompt_code": "def __getattr__(self, attr):\n    \"\"\"Asserts that val has attribute attr and that attribute's value is equal to other via a dynamic assertion of the form: has_<attr>().\"\"\"\n    if not attr.startswith('has_'):\n        raise AttributeError('assertpy has no assertion <%s()>' % attr)\n\n    attr_name = attr[4:]\n    if not hasattr(self.val, attr_name):\n        raise AttributeError('val has no attribute <%s>' % attr_name)\n\n    def _wrapper(*args, **kwargs):\n        if len(args) < 1:\n            raise TypeError('assertion <%s()> takes exactly 1 argument (%d given)' % (attr, len(args)))\n        other = args[0]\n        val_attr = getattr(self.val, attr_name)\n\n        if callable(val_attr):\n            try:\n                val = val_attr()\n            except TypeError:\n                raise TypeError('val does not have zero-arg method <%s()>' % attr_name)\n        else:\n            val = val_attr\n\n        if val != other:\n            self._err('Expected <%s> to be equal to <%s>, but was not.' % (val, other))\n        return self\n    return _wrapper"}
{"correct_code": "def validate_file(self,filename):\n    import os.path\n    base,ext = os.path.splitext(filename)\n    if ext != '.py': return         # No idea what the file is. Return OK\n\n    try:\n        f = open(filename)\n        lines = f.readlines()\n        f.close()\n    except IOError:\n        return                      # Couldn't find the file.  Don't worry about it\n\n    fre = re.compile(r'\\s*def\\s+(t_[a-zA-Z_0-9]*)\\(')\n    sre = re.compile(r'\\s*(t_[a-zA-Z_0-9]*)\\s*=')\n\n    counthash = { }\n    linen = 1\n    for l in lines:\n        m = fre.match(l)\n        if not m:\n            m = sre.match(l)\n        if m:\n            name = m.group(1)\n            prev = counthash.get(name)\n            if not prev:\n                counthash[name] = linen\n            else:\n                self.log.error(\"%s:%d: Rule %s redefined. Previously defined on line %d\",filename,linen,name,prev)\n                self.error = 1\n        linen += 1", "prompt_code": "def validate_file(self,filename):\n    import os.path\n    base,ext = os.path.splitext(filename)\n    if ext in '.py': return         # No idea what the file is. Return OK\n\n    try:\n        f = open(filename)\n        lines = f.readlines()\n        f.close()\n    except IOError:\n        return                      # Couldn't find the file.  Don't worry about it\n\n    fre = re.compile(r'\\s*def\\s+(t_[a-zA-Z_0-9]*)\\(')\n    sre = re.compile(r'\\s*(t_[a-zA-Z_0-9]*)\\s*=')\n\n    counthash = { }\n    linen = 1\n    for l in lines:\n        m = fre.match(l)\n        if not m:\n            m = sre.match(l)\n        if m:\n            name = m.group(1)\n            prev = counthash.get(name)\n            if not prev:\n                counthash[name] = linen\n            else:\n                self.log.error(\"%s:%d: Rule %s redefined. Previously defined on line %d\",filename,linen,name,prev)\n                self.error = 1\n        linen += 1"}
{"correct_code": "def get_order(self, aBuf):\n    # for euc-KR encoding, we are interested\n    #   first  byte range: 0xb0 -- 0xfe\n    #   second byte range: 0xa1 -- 0xfe\n    # no validation needed here. State machine has done that\n    first_char = wrap_ord(aBuf[0])\n    if first_char >= 0xB0:\n        return 94 * (first_char - 0xB0) + wrap_ord(aBuf[1]) - 0xA1\n    else:\n        return -1", "prompt_code": "def get_order(self, aBuf):\n    # for euc-KR encoding, we are interested\n    #   first  byte range: 0xb0 -- 0xfe\n    #   second byte range: 0xa1 -- 0xfe\n    # no validation needed here. State machine has done that\n    first_char = wrap_ord(aBuf[0])\n    if first_char >= 0xB0:\n        return 94 * (first_char - 0xB0) * wrap_ord(aBuf[1]) - 0xA1\n    else:\n        return -1"}
{"correct_code": "def _send(self, s):\n    if not self.isalive():\n        raise EOF('Attempted write to a closed file descriptor')\n    if pty:\n        return os.write(self.child_fd, s)\n    else:\n        try:\n                return os.write(self.write_fd, s)\n        except OSError as e:\n                if e.errno == errno.EINVAL:\n                        raise EOF('Attempted write to a closed file descriptor')\n                else:\n                        raise(e)", "prompt_code": "def _send(self, s):\n    if not self.isalive():\n        raise EOF('Attempted write to a closed file descriptor')\n    if pty:\n        return os.write(self.child_fd, s)\n    else:\n        try:\n                return os.write(self.write_fd, s)\n        except OSError as e:\n                if e.errno < errno.EINVAL:\n                        raise EOF('Attempted write to a closed file descriptor')\n                else:\n                        raise(e)"}
