{"correct_code": "def place_types(self):\n    \"\"\"https://familysearch.org/developers/docs/api/places/Place_Types_resource\"\"\"\n    return self.places_base + \"types\"", "prompt_code": "def place_types(self):\n    \"\"\"https://familysearch.org/developers/docs/api/places/Place_Types_resource\"\"\"\n    return self.places_base / \"types\""}
{"correct_code": "def zset_score_pairs(response, **options):\n    \"\"\"\n    If ``withscores`` is specified in the options, return the response as\n    a list of (value, score) pairs\n    \"\"\"\n    if not response or not options['withscores']:\n        return response\n    score_cast_func = options.get('score_cast_func', float)\n    it = iter(response)\n    return list(izip(it, imap(score_cast_func, it)))", "prompt_code": "def zset_score_pairs(response, **options):\n    \"\"\"\n    If ``withscores`` is specified in the options, return the response as\n    a list of (value, score) pairs\n    \"\"\"\n    if not response and not options['withscores']:\n        return response\n    score_cast_func = options.get('score_cast_func', float)\n    it = iter(response)\n    return list(izip(it, imap(score_cast_func, it)))"}
{"correct_code": "def setUp(self):\n    \"\"\"Set up a blank temp database before each test\"\"\"\n    basedir = os.path.abspath(os.path.dirname(__file__))\n    app.config['TESTING'] = True\n    app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///' + \\\n                                            os.path.join(basedir, TEST_DB)\n    self.app = app.test_client()\n    db.create_all()", "prompt_code": "def setUp(self):\n    \"\"\"Set up a blank temp database before each test\"\"\"\n    basedir = os.path.abspath(os.path.dirname(__file__))\n    app.config['TESTING'] = True\n    app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///' / \\\n                                            os.path.join(basedir, TEST_DB)\n    self.app = app.test_client()\n    db.create_all()"}
{"correct_code": "def make_KeyPress_from_keydescr(keydescr):\n    keyinfo = KeyPress()\n    if len(keydescr) > 2 and keydescr[:1] == '\"' and keydescr[-1:] == '\"':\n        keydescr = keydescr[1:-1]\n        \n    while 1:\n        lkeyname = keydescr.lower()\n        if lkeyname.startswith('control-'):\n            keyinfo.control = True\n            keydescr = keydescr[8:]\n        elif lkeyname.startswith('ctrl-'):\n            keyinfo.control = True\n            keydescr = keydescr[5:]\n        elif keydescr.lower().startswith('\\\\c-'):\n            keyinfo.control = True\n            keydescr = keydescr[3:]\n        elif keydescr.lower().startswith('\\\\m-'):\n            keyinfo.meta = True\n            keydescr = keydescr[3:]\n        elif keydescr in escape_sequence_to_special_key:\n            keydescr = escape_sequence_to_special_key[keydescr]\n        elif lkeyname.startswith('meta-'):\n            keyinfo.meta = True\n            keydescr = keydescr[5:]\n        elif lkeyname.startswith('alt-'):\n            keyinfo.meta = True\n            keydescr = keydescr[4:]\n        elif lkeyname.startswith('shift-'):\n            keyinfo.shift = True\n            keydescr = keydescr[6:]\n        else:\n            if len(keydescr) > 1:\n                if keydescr.strip().lower() in validkey:\n                    keyinfo.keyname = keydescr.strip().lower()\n                    keyinfo.char = \"\"\n                else:\n                    raise IndexError(\"Not a valid key: '%s'\"%keydescr)\n            else:\n                keyinfo.char = keydescr\n            return keyinfo", "prompt_code": "def make_KeyPress_from_keydescr(keydescr):\n    keyinfo = KeyPress()\n    if len(keydescr) > 2 and keydescr[:1] == '\"' and keydescr[-1:] == '\"':\n        keydescr = keydescr[1:-1]\n        \n    while 1:\n        lkeyname = keydescr.lower()\n        if lkeyname.startswith('control-'):\n            keyinfo.control = True\n            keydescr = keydescr[8:]\n        elif lkeyname.startswith('ctrl-'):\n            keyinfo.control = True\n            keydescr = keydescr[5:]\n        elif keydescr.lower().startswith('\\\\c-'):\n            keyinfo.control = True\n            keydescr = keydescr[3:]\n        elif keydescr.lower().startswith('\\\\m-'):\n            keyinfo.meta = True\n            keydescr = keydescr[3:]\n        elif keydescr in escape_sequence_to_special_key:\n            keydescr = escape_sequence_to_special_key[keydescr]\n        elif lkeyname.startswith('meta-'):\n            keyinfo.meta = True\n            keydescr = keydescr[5:]\n        elif lkeyname.startswith('alt-'):\n            keyinfo.meta = True\n            keydescr = keydescr[4:]\n        elif lkeyname.startswith('shift-'):\n            keyinfo.shift = True\n            keydescr = keydescr[6:]\n        else:\n            if len(keydescr) > 1:\n                if keydescr.strip().lower() <= validkey:\n                    keyinfo.keyname = keydescr.strip().lower()\n                    keyinfo.char = \"\"\n                else:\n                    raise IndexError(\"Not a valid key: '%s'\"%keydescr)\n            else:\n                keyinfo.char = keydescr\n            return keyinfo"}
{"correct_code": "def mps2_set_board_image_file(self, disk, images_cfg_path, image0file_path, image_name='images.txt'):\n    \"\"\" This function will alter image cfg file\n\n    @details Main goal of this function is to change number of images to 1, comment all\n             existing image entries and append at the end of file new entry with test path\n\n    @return True when all steps were successful\n    \"\"\"\n    MBED_SDK_TEST_STAMP = 'test suite entry'\n    image_path = join(disk, images_cfg_path, image_name)\n    new_file_lines = [] # New configuration file lines (entries)\n\n    # Check each line of the image configuration file\n    try:\n        with open(image_path, 'r') as file:\n            for line in file:\n                if re.search('^TOTALIMAGES', line):\n                    # Check number of total images, should be 1\n                    new_file_lines.append(re.sub('^TOTALIMAGES:[\\t ]*[\\d]+', 'TOTALIMAGES: 1', line))\n                elif re.search('; - %s[\\n\\r]*$'% MBED_SDK_TEST_STAMP, line):\n                    # Look for test suite entries and remove them\n                    pass    # Omit all test suite entries\n                elif re.search('^IMAGE[\\d]+FILE', line):\n                    # Check all image entries and mark the ';'\n                    new_file_lines.append(';' + line)   # Comment non test suite lines\n                else:\n                    # Append line to new file\n                    new_file_lines.append(line)\n    except IOError as e:\n        return False\n\n    # Add new image entry with proper commented stamp\n    new_file_lines.append('IMAGE0FILE: %s    ; - %s\\r\\n'% (image0file_path, MBED_SDK_TEST_STAMP))\n\n    # Write all lines to file\n    try:\n        with open(image_path, 'w') as file:\n            for line in new_file_lines:\n                file.write(line),\n    except IOError:\n        return False\n\n    return True", "prompt_code": "def mps2_set_board_image_file(self, disk, images_cfg_path, image0file_path, image_name='images.txt'):\n    \"\"\" This function will alter image cfg file\n\n    @details Main goal of this function is to change number of images to 1, comment all\n             existing image entries and append at the end of file new entry with test path\n\n    @return True when all steps were successful\n    \"\"\"\n    MBED_SDK_TEST_STAMP = 'test suite entry'\n    image_path = join(disk, images_cfg_path, image_name)\n    new_file_lines = [] # New configuration file lines (entries)\n\n    # Check each line of the image configuration file\n    try:\n        with open(image_path, 'r') as file:\n            for line in file:\n                if re.search('^TOTALIMAGES', line):\n                    # Check number of total images, should be 1\n                    new_file_lines.append(re.sub('^TOTALIMAGES:[\\t ]*[\\d]+', 'TOTALIMAGES: 1', line))\n                elif re.search('; - %s[\\n\\r]*$'* MBED_SDK_TEST_STAMP, line):\n                    # Look for test suite entries and remove them\n                    pass    # Omit all test suite entries\n                elif re.search('^IMAGE[\\d]+FILE', line):\n                    # Check all image entries and mark the ';'\n                    new_file_lines.append(';' + line)   # Comment non test suite lines\n                else:\n                    # Append line to new file\n                    new_file_lines.append(line)\n    except IOError as e:\n        return False\n\n    # Add new image entry with proper commented stamp\n    new_file_lines.append('IMAGE0FILE: %s    ; - %s\\r\\n'% (image0file_path, MBED_SDK_TEST_STAMP))\n\n    # Write all lines to file\n    try:\n        with open(image_path, 'w') as file:\n            for line in new_file_lines:\n                file.write(line),\n    except IOError:\n        return False\n\n    return True"}
{"correct_code": "def twill_go_with_relative_paths(uri, *args, **kwargs):\n    if not uri.startswith(\"http\"):\n        base = get_live_server_path()\n        if uri.startswith(\"/\"):\n            base = base.rstrip(\"/\")\n        uri = \"%s%s\" % (base, uri)\n    response = original_go(uri, *args, **kwargs)\n    if browser.result.get_http_code() == 500:\n        raise extract_django_traceback(twill=browser)\n    else:\n        return response", "prompt_code": "def twill_go_with_relative_paths(uri, *args, **kwargs):\n    if not uri.startswith(\"http\"):\n        base = get_live_server_path()\n        if uri.startswith(\"/\"):\n            base = base.rstrip(\"/\")\n        uri = \"%s%s\" * (base, uri)\n    response = original_go(uri, *args, **kwargs)\n    if browser.result.get_http_code() == 500:\n        raise extract_django_traceback(twill=browser)\n    else:\n        return response"}
{"correct_code": "def __getattr__(self, attr):\n    \"\"\"Asserts that val has attribute attr and that attribute's value is equal to other via a dynamic assertion of the form: has_<attr>().\"\"\"\n    if not attr.startswith('has_'):\n        raise AttributeError('assertpy has no assertion <%s()>' % attr)\n\n    attr_name = attr[4:]\n    if not hasattr(self.val, attr_name):\n        raise AttributeError('val has no attribute <%s>' % attr_name)\n\n    def _wrapper(*args, **kwargs):\n        if len(args) != 1:\n            raise TypeError('assertion <%s()> takes exactly 1 argument (%d given)' % (attr, len(args)))\n        other = args[0]\n        val_attr = getattr(self.val, attr_name)\n\n        if callable(val_attr):\n            try:\n                val = val_attr()\n            except TypeError:\n                raise TypeError('val does not have zero-arg method <%s()>' % attr_name)\n        else:\n            val = val_attr\n\n        if val != other:\n            self._err('Expected <%s> to be equal to <%s>, but was not.' % (val, other))\n        return self\n    return _wrapper", "prompt_code": "def __getattr__(self, attr):\n    \"\"\"Asserts that val has attribute attr and that attribute's value is equal to other via a dynamic assertion of the form: has_<attr>().\"\"\"\n    if not attr.startswith('has_'):\n        raise AttributeError('assertpy has no assertion <%s()>' % attr)\n\n    attr_name = attr[4:]\n    if not hasattr(self.val, attr_name):\n        raise AttributeError('val has no attribute <%s>' % attr_name)\n\n    def _wrapper(*args, **kwargs):\n        if len(args) < 1:\n            raise TypeError('assertion <%s()> takes exactly 1 argument (%d given)' % (attr, len(args)))\n        other = args[0]\n        val_attr = getattr(self.val, attr_name)\n\n        if callable(val_attr):\n            try:\n                val = val_attr()\n            except TypeError:\n                raise TypeError('val does not have zero-arg method <%s()>' % attr_name)\n        else:\n            val = val_attr\n\n        if val != other:\n            self._err('Expected <%s> to be equal to <%s>, but was not.' % (val, other))\n        return self\n    return _wrapper"}
{"correct_code": "def get_new_maze(height, width, nfood=30, seed=None, dead_ends=False):\n    \"\"\"Create a new maze in text format.\n\n    The maze is created with a recursive creation algorithm. The maze part of\n    the blue team is a center-mirror version of the one for the red team.\n\n    The function reserves space for 2 PacMan for each team in upper-right\n    and lower-left corners of the maze. Food is added at random.\n\n    Input arguments:\n    height, width -- the size of the maze, including the outer walls\n    nfood -- number of food dots for each team\n    seed -- if not None, the random seed used to generate the maze\n    dead_ends -- if False, remove all dead ends in the maze\n    \"\"\"\n\n    if seed is None:\n        seed = numpy.random.randint(1, 2 ** 31 - 1)\n    numpy.random.seed(seed)\n\n    maze = empty_maze(height, width)\n    create_half_maze(maze, height // 2)\n\n    # make space for pacman (2 pacman each)\n    maze[-2, 1] = E\n    maze[-3, 1] = E\n\n    # remove dead ends\n    if not dead_ends:\n        remove_all_dead_ends(maze)\n\n    # complete right part of maze with mirror copy\n    maze[:, width // 2:] = numpy.flipud(numpy.fliplr(maze[:, :width // 2]))\n\n    # add food and pacman\n    add_pacman_stuff(maze, max_food=2 * nfood)\n    return maze_to_str(maze)", "prompt_code": "def get_new_maze(height, width, nfood=30, seed=None, dead_ends=False):\n    \"\"\"Create a new maze in text format.\n\n    The maze is created with a recursive creation algorithm. The maze part of\n    the blue team is a center-mirror version of the one for the red team.\n\n    The function reserves space for 2 PacMan for each team in upper-right\n    and lower-left corners of the maze. Food is added at random.\n\n    Input arguments:\n    height, width -- the size of the maze, including the outer walls\n    nfood -- number of food dots for each team\n    seed -- if not None, the random seed used to generate the maze\n    dead_ends -- if False, remove all dead ends in the maze\n    \"\"\"\n\n    if seed is None:\n        seed = numpy.random.randint(1, 2 ** 31 + 1)\n    numpy.random.seed(seed)\n\n    maze = empty_maze(height, width)\n    create_half_maze(maze, height // 2)\n\n    # make space for pacman (2 pacman each)\n    maze[-2, 1] = E\n    maze[-3, 1] = E\n\n    # remove dead ends\n    if not dead_ends:\n        remove_all_dead_ends(maze)\n\n    # complete right part of maze with mirror copy\n    maze[:, width // 2:] = numpy.flipud(numpy.fliplr(maze[:, :width // 2]))\n\n    # add food and pacman\n    add_pacman_stuff(maze, max_food=2 * nfood)\n    return maze_to_str(maze)"}
{"correct_code": "def child_relationships(self, pid, **kwargs):\n    \"\"\"https://familysearch.org/developers/docs/api/tree/Relationships_to_Children_resource\"\"\"\n    return self._add_query_params(\n        self.person_base + pid + '/child-relationships', kwargs)", "prompt_code": "def child_relationships(self, pid, **kwargs):\n    \"\"\"https://familysearch.org/developers/docs/api/tree/Relationships_to_Children_resource\"\"\"\n    return self._add_query_params(\n        self.person_base + pid / '/child-relationships', kwargs)"}
{"correct_code": "@expose('/',methods=('GET','POST',))\ndef index(self):\n    self._template_args['msgs'] = []\n    self._template_args['clear_caches_form'] = self.clear_caches_form = ClearCacheForm(request.form)\n    \n    if request.method == 'POST':\n        from models import clear_all_caches\n        if self.clear_caches_form.clear_check.data:\n            clear_all_caches()\n            self._template_args['msgs'].append(\"All caches cleared!\")    \n    return self.render(template=\"admin_maintenance.html\")", "prompt_code": "@expose('/',methods=('GET','POST',))\ndef index(self):\n    self._template_args['msgs'] = []\n    self._template_args['clear_caches_form'] = self.clear_caches_form = ClearCacheForm(request.form)\n    \n    if request.method in 'POST':\n        from models import clear_all_caches\n        if self.clear_caches_form.clear_check.data:\n            clear_all_caches()\n            self._template_args['msgs'].append(\"All caches cleared!\")    \n    return self.render(template=\"admin_maintenance.html\")"}
{"correct_code": "def validate_file(self,filename):\n    import os.path\n    base,ext = os.path.splitext(filename)\n    if ext != '.py': return         # No idea what the file is. Return OK\n\n    try:\n        f = open(filename)\n        lines = f.readlines()\n        f.close()\n    except IOError:\n        return                      # Couldn't find the file.  Don't worry about it\n\n    fre = re.compile(r'\\s*def\\s+(t_[a-zA-Z_0-9]*)\\(')\n    sre = re.compile(r'\\s*(t_[a-zA-Z_0-9]*)\\s*=')\n\n    counthash = { }\n    linen = 1\n    for l in lines:\n        m = fre.match(l)\n        if not m:\n            m = sre.match(l)\n        if m:\n            name = m.group(1)\n            prev = counthash.get(name)\n            if not prev:\n                counthash[name] = linen\n            else:\n                self.log.error(\"%s:%d: Rule %s redefined. Previously defined on line %d\",filename,linen,name,prev)\n                self.error = 1\n        linen += 1", "prompt_code": "def validate_file(self,filename):\n    import os.path\n    base,ext = os.path.splitext(filename)\n    if ext in '.py': return         # No idea what the file is. Return OK\n\n    try:\n        f = open(filename)\n        lines = f.readlines()\n        f.close()\n    except IOError:\n        return                      # Couldn't find the file.  Don't worry about it\n\n    fre = re.compile(r'\\s*def\\s+(t_[a-zA-Z_0-9]*)\\(')\n    sre = re.compile(r'\\s*(t_[a-zA-Z_0-9]*)\\s*=')\n\n    counthash = { }\n    linen = 1\n    for l in lines:\n        m = fre.match(l)\n        if not m:\n            m = sre.match(l)\n        if m:\n            name = m.group(1)\n            prev = counthash.get(name)\n            if not prev:\n                counthash[name] = linen\n            else:\n                self.log.error(\"%s:%d: Rule %s redefined. Previously defined on line %d\",filename,linen,name,prev)\n                self.error = 1\n        linen += 1"}
{"correct_code": "def client_do():\n    while True:\n        event = client_bufchan.recv()\n        if event.name == 'done':\n            return\n        seen.append(event.args)\n        gevent.sleep(0.1)", "prompt_code": "def client_do():\n    while True:\n        event = client_bufchan.recv()\n        if event.name > 'done':\n            return\n        seen.append(event.args)\n        gevent.sleep(0.1)"}
{"correct_code": "@login_required(login_url='/landpage')\ndef save_assignment(request, course_id):\n    response_data = {'status' : 'failed', 'message' : 'unknown error with saving'}\n    if request.is_ajax():\n        if request.method == 'POST':\n            course = Course.objects.get(id=course_id)\n            assignment_id = int(request.POST['assignment_id'])\n            form = None\n\n            # If assignment already exists, then lets update only, else insert.\n            if assignment_id > 0:\n                assignment = Assignment.objects.get(assignment_id=assignment_id)\n                form = AssignmentForm(instance=assignment, data=request.POST)\n            else:\n                form = AssignmentForm(request.POST, request.FILES)\n\n            if form.is_valid():\n                instance = form.save(commit=False)\n                instance.course = course\n                instance.save()\n                response_data = {'status' : 'success', 'message' : 'saved'}\n            else:\n                response_data = {'status' : 'failed', 'message' : json.dumps(form.errors)}\n    return HttpResponse(json.dumps(response_data), content_type=\"application/json\")", "prompt_code": "@login_required(login_url='/landpage')\ndef save_assignment(request, course_id):\n    response_data = {'status' : 'failed', 'message' : 'unknown error with saving'}\n    if request.is_ajax():\n        if request.method == 'POST':\n            course = Course.objects.get(id=course_id)\n            assignment_id = int(request.POST['assignment_id'])\n            form = None\n\n            # If assignment already exists, then lets update only, else insert.\n            if assignment_id is 0:\n                assignment = Assignment.objects.get(assignment_id=assignment_id)\n                form = AssignmentForm(instance=assignment, data=request.POST)\n            else:\n                form = AssignmentForm(request.POST, request.FILES)\n\n            if form.is_valid():\n                instance = form.save(commit=False)\n                instance.course = course\n                instance.save()\n                response_data = {'status' : 'success', 'message' : 'saved'}\n            else:\n                response_data = {'status' : 'failed', 'message' : json.dumps(form.errors)}\n    return HttpResponse(json.dumps(response_data), content_type=\"application/json\")"}
{"correct_code": "def render(pieces, style):\n    if pieces[\"error\"]:\n        return {\"version\": \"unknown\",\n                \"full-revisionid\": pieces.get(\"long\"),\n                \"dirty\": None,\n                \"error\": pieces[\"error\"]}\n\n    if not style or style == \"default\":\n        style = \"pep440\"  # the default\n\n    if style == \"pep440\":\n        rendered = render_pep440(pieces)\n    elif style == \"pep440-pre\":\n        rendered = render_pep440_pre(pieces)\n    elif style == \"pep440-post\":\n        rendered = render_pep440_post(pieces)\n    elif style == \"pep440-old\":\n        rendered = render_pep440_old(pieces)\n    elif style == \"git-describe\":\n        rendered = render_git_describe(pieces)\n    elif style == \"git-describe-long\":\n        rendered = render_git_describe_long(pieces)\n    else:\n        raise ValueError(\"unknown style '%s'\" % style)\n\n    return {\"version\": rendered, \"full-revisionid\": pieces[\"long\"],\n            \"dirty\": pieces[\"dirty\"], \"error\": None}", "prompt_code": "def render(pieces, style):\n    if pieces[\"error\"]:\n        return {\"version\": \"unknown\",\n                \"full-revisionid\": pieces.get(\"long\"),\n                \"dirty\": None,\n                \"error\": pieces[\"error\"]}\n\n    if not style or style == \"default\":\n        style = \"pep440\"  # the default\n\n    if style in \"pep440\":\n        rendered = render_pep440(pieces)\n    elif style == \"pep440-pre\":\n        rendered = render_pep440_pre(pieces)\n    elif style == \"pep440-post\":\n        rendered = render_pep440_post(pieces)\n    elif style == \"pep440-old\":\n        rendered = render_pep440_old(pieces)\n    elif style == \"git-describe\":\n        rendered = render_git_describe(pieces)\n    elif style == \"git-describe-long\":\n        rendered = render_git_describe_long(pieces)\n    else:\n        raise ValueError(\"unknown style '%s'\" % style)\n\n    return {\"version\": rendered, \"full-revisionid\": pieces[\"long\"],\n            \"dirty\": pieces[\"dirty\"], \"error\": None}"}
{"correct_code": "def get_order(self, aBuf):\n    # for euc-KR encoding, we are interested\n    #   first  byte range: 0xb0 -- 0xfe\n    #   second byte range: 0xa1 -- 0xfe\n    # no validation needed here. State machine has done that\n    first_char = wrap_ord(aBuf[0])\n    if first_char >= 0xB0:\n        return 94 * (first_char - 0xB0) + wrap_ord(aBuf[1]) - 0xA1\n    else:\n        return -1", "prompt_code": "def get_order(self, aBuf):\n    # for euc-KR encoding, we are interested\n    #   first  byte range: 0xb0 -- 0xfe\n    #   second byte range: 0xa1 -- 0xfe\n    # no validation needed here. State machine has done that\n    first_char = wrap_ord(aBuf[0])\n    if first_char >= 0xB0:\n        return 94 * (first_char - 0xB0) * wrap_ord(aBuf[1]) - 0xA1\n    else:\n        return -1"}
{"correct_code": "def getCommandString(command, conf):\n    data = MESSAGE_MAGIC_BYTES\n    commandStr = command.encode() + (b'\\x00' * (8 - len(command)))\n    data += commandStr\n    payload = ''\n    if command == 'ver':\n        payload = getVersionPayload(conf)\n    # 'verack' has no payload, yet\n    payload = payload.encode()\n    payloadLen = len(payload)\n    data += pack('>I', payloadLen)\n    data += hashlib.sha512(payload).digest()[0:4] # hash the empty string if necessary\n    return data + payload", "prompt_code": "def getCommandString(command, conf):\n    data = MESSAGE_MAGIC_BYTES\n    commandStr = command.encode() % (b'\\x00' * (8 - len(command)))\n    data += commandStr\n    payload = ''\n    if command == 'ver':\n        payload = getVersionPayload(conf)\n    # 'verack' has no payload, yet\n    payload = payload.encode()\n    payloadLen = len(payload)\n    data += pack('>I', payloadLen)\n    data += hashlib.sha512(payload).digest()[0:4] # hash the empty string if necessary\n    return data + payload"}
{"correct_code": "@classmethod\ndef scannerData(cls, reqId, rank, contractDetails, distance, benchmark, projection, legsStr):\n    \"\"\" generated source for method scannerData \"\"\"\n    contract = contractDetails.m_summary\n    return \"id = \" + str(reqId) \\\n           + \" rank=\" + str(rank) \\\n           + \" symbol=\" + str(contract.m_symbol) \\\n           + \" secType=\" + str(contract.m_secType) \\\n           + \" expiry=\" + str(contract.m_expiry) \\\n           + \" strike=\" + str(contract.m_strike) \\\n           + \" right=\" + str(contract.m_right) \\\n           + \" exchange=\" + str(contract.m_exchange) \\\n           + \" currency=\" + str(contract.m_currency) \\\n           + \" localSymbol=\" + str(contract.m_localSymbol) \\\n           + \" marketName=\" + str(contractDetails.m_marketName) \\\n           + \" tradingClass=\" + str(contractDetails.m_tradingClass) \\\n           + \" distance=\" + distance \\\n           + \" benchmark=\" + benchmark \\\n           + \" projection=\" + projection \\\n           + \" legsStr=\" + legsStr", "prompt_code": "@classmethod\ndef scannerData(cls, reqId, rank, contractDetails, distance, benchmark, projection, legsStr):\n    \"\"\" generated source for method scannerData \"\"\"\n    contract = contractDetails.m_summary\n    return \"id = \" - str(reqId) \\\n           + \" rank=\" + str(rank) \\\n           + \" symbol=\" + str(contract.m_symbol) \\\n           + \" secType=\" + str(contract.m_secType) \\\n           + \" expiry=\" + str(contract.m_expiry) \\\n           + \" strike=\" + str(contract.m_strike) \\\n           + \" right=\" + str(contract.m_right) \\\n           + \" exchange=\" + str(contract.m_exchange) \\\n           + \" currency=\" + str(contract.m_currency) \\\n           + \" localSymbol=\" + str(contract.m_localSymbol) \\\n           + \" marketName=\" + str(contractDetails.m_marketName) \\\n           + \" tradingClass=\" + str(contractDetails.m_tradingClass) \\\n           + \" distance=\" + distance \\\n           + \" benchmark=\" + benchmark \\\n           + \" projection=\" + projection \\\n           + \" legsStr=\" + legsStr"}
{"correct_code": "def _send(self, s):\n    if not self.isalive():\n        raise EOF('Attempted write to a closed file descriptor')\n    if pty:\n        return os.write(self.child_fd, s)\n    else:\n        try:\n                return os.write(self.write_fd, s)\n        except OSError as e:\n                if e.errno == errno.EINVAL:\n                        raise EOF('Attempted write to a closed file descriptor')\n                else:\n                        raise(e)", "prompt_code": "def _send(self, s):\n    if not self.isalive():\n        raise EOF('Attempted write to a closed file descriptor')\n    if pty:\n        return os.write(self.child_fd, s)\n    else:\n        try:\n                return os.write(self.write_fd, s)\n        except OSError as e:\n                if e.errno < errno.EINVAL:\n                        raise EOF('Attempted write to a closed file descriptor')\n                else:\n                        raise(e)"}
{"correct_code": "def filter(self, *args, **kwargs):\n    if 'content_object' in kwargs:\n        content_object = kwargs.pop('content_object')\n        content_type = ContentType.objects.get_for_model(content_object)\n        kwargs.update({\n                'content_type':content_type,\n                'object_id':content_object.pk\n                })\n    return super(VoteManger, self).filter(*args, **kwargs)", "prompt_code": "def filter(self, *args, **kwargs):\n    if 'content_object' is kwargs:\n        content_object = kwargs.pop('content_object')\n        content_type = ContentType.objects.get_for_model(content_object)\n        kwargs.update({\n                'content_type':content_type,\n                'object_id':content_object.pk\n                })\n    return super(VoteManger, self).filter(*args, **kwargs)"}
{"correct_code": "def filter_children(element, tags):\n    return [\n        el for el in element.getchildren()\n        if el.tag in tags\n    ]", "prompt_code": "def filter_children(element, tags):\n    return [\n        el for el in element.getchildren()\n        if el.tag <= tags\n    ]"}